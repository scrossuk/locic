// Program entry point.

int rand();

int strcmp(const char* const first, const char* const second);

void printf(const char* text, ...);

double Random(){
	// Not a great random number generator...
	return (rand() % 100).toFloat() / 100.0f;
}

double SRandom(){
	return 2.0 * Random() - 1.0;
}

void initializeBoard(CR::Board& board){
	for (auto x: std::counter<size_t>(1u, 0u, board.size().width)) {
		for (auto y: std::counter<size_t>(1u, 0u, board.size().height)) {
			board[CR::Position(x, y)] = CR::Empty();
		}
	}
	
	const bool position = (Random() > 0.5);
	
	final auto width = board.size().width;
	final auto height = board.size().height;

	// Add initial positions.
	board[CR::Position(width / 2u - 1u, height / 2u - 1u)] = position ? CR::Red() : CR::Blue();
	board[CR::Position(width / 2u, height / 2u)]           = position ? CR::Red() : CR::Blue();
	board[CR::Position(width / 2u - 1u, height / 2u)]      = position ? CR::Blue() : CR::Red();
	board[CR::Position(width / 2u, height / 2u - 1u)]      = position ? CR::Blue() : CR::Red();
}

void playGame(sf::RenderWindow& renderWindow, CR::Player& player0, CR::Player& player1) {
	final auto boardSize = CR::BoardSize(8u, 8u);
	final auto initialColour = Random() > 0.5 ? CR::Red() : CR::Blue();
	final auto board = CR::Board(boardSize, initialColour);
	
	CR::Value lastWinner = CR::Red();
	
	initializeBoard(board);
	
	// Whether a game is currently active.
	bool playing = true;
	
	// Whether p0 (false) or p1 (true) is the current player.
	bool currentPlayer = Random() > 0.5;
	
	auto clock = sf::Clock();
	
	final auto font = sf::Font(C"Data/font.ttf");
	
	while (renderWindow.isOpen()) {
		auto event = sfEvent(0, 0u);
		
		while (renderWindow.pollEvent(&event)) {
			if (event.type == 0) {
				renderWindow.close();
			}
		}
		
		if (playing) {
			if (!board.isComplete()) {
				if (!currentPlayer) {
					auto optionalPosition = player0.performMove(board);
					
					switch (optionalPosition) {
						case CR::Some(CR::Position position) {
							board.placeMove(position);
							currentPlayer = true;
						}
						case CR::None() { }
					}
				} else {
					auto optionalPosition = player1.performMove(board);
					
					switch (optionalPosition) {
						case CR::Some(CR::Position position) {
							board.placeMove(position);
							currentPlayer = false;
						}
						case CR::None() { }
					}
				}
			} else {
				// Indicate the result to players.
				if (!currentPlayer) {
					player0.gameOver(false);
					player1.gameOver(true);
				} else {
					
					player0.gameOver(true);
					player1.gameOver(false);
				}
				
				playing = false;
				lastWinner = board.opponent();
			}
			clock.restart();
		} else if(clock.getElapsedTime().asSeconds() > 5.0f) {
			playing = true;
			currentPlayer = Random() > 0.5;
			initializeBoard(board);
		}
		
		// Clear screen to black.
		renderWindow.clear(sf::Color(0u, 0u, 0u, 255u));
		
		for (auto x: std::counter<size_t>(1u, 0u, board.size().width)) {
			for (auto y: std::counter<size_t>(1u, 0u, board.size().height)) {
				auto backgroundCircle = sf::CircleShape();
				backgroundCircle.setRadius(45.0f);
				backgroundCircle.setFillColor(sf::Color(20u, 20u, 20u, 255u));
				backgroundCircle.setPosition(sf::Vector2f(x.toFloat() * 100.0f + 5.0f, y.toFloat() * 100.0f + 5.0f));
				renderWindow.drawCircle(backgroundCircle);
				
				final const auto position = CR::Position(x, y);
				
				auto foregroundCircle = sf::CircleShape();
				foregroundCircle.setRadius(40.0f);
				
				switch (board[position]) {
					case CR::Red() {
						if (playing) {
							foregroundCircle.setFillColor(sf::Color(255u, 0u, 0u, 255u));
						} else {
							foregroundCircle.setFillColor(sf::Color(150u, 0u, 0u, 255u));
						}
					}
					case CR::Blue() {
						if (playing) {
							foregroundCircle.setFillColor(sf::Color(0u, 0u, 255u, 255u));
						} else {
							foregroundCircle.setFillColor(sf::Color(0u, 0u, 150u, 255u));
						}
					}
					case CR::Empty() {
						if (board.isValid(position)) {
							foregroundCircle.setFillColor(sf::Color(70u, 70u, 70u, 255u));
						} else {
							foregroundCircle.setFillColor(sf::Color(30u, 30u, 30u, 255u));
						}
					}
				}
				
				foregroundCircle.setPosition(sf::Vector2f(x.toFloat() * 100.0f + 10.0f, y.toFloat() * 100.0f + 10.0f));
				renderWindow.drawCircle(foregroundCircle);
			}
		}
		
		if (!playing) {
			auto winnerText = sf::Text();
			winnerText.setFont(font);
			winnerText.setCharacterSize(100u);
			winnerText.setColor(sf::Color(255u, 255u, 255u, 255u));
			
			switch (lastWinner) {
				case CR::Red() {
					winnerText.setString(C"Red wins!");
				}
				case CR::Blue() {
					winnerText.setString(C"Blue wins!");
				}
				case CR::Empty() {
				}
			}
			
			final const auto textLocalRect = winnerText.getLocalBounds();
			winnerText.setOrigin(sf::Vector2f(textLocalRect.topLeft.x + textLocalRect.size.x / 2.0f,
					textLocalRect.topLeft.y + textLocalRect.size.y / 2.0f));
			
			winnerText.setPosition(sf::Vector2f(400.0f, 400.0f));
			
			final const auto textGlobalRect = winnerText.getGlobalBounds();
			
			const float extraWidth = textGlobalRect.size.x * 0.5f;
			const float extraHeight = textGlobalRect.size.y * 0.5f;
			
			final auto winnerTextBackground = sf::RectangleShape();
			winnerTextBackground.setSize(sf::Vector2f(textGlobalRect.size.x + extraWidth, textGlobalRect.size.y + extraHeight));
			winnerTextBackground.setPosition(sf::Vector2f(textGlobalRect.topLeft.x - extraWidth / 2.0f,
				textGlobalRect.topLeft.y - extraHeight / 2.0f));
			winnerTextBackground.setFillColor(sf::Color(0u, 0u, 0u, 200u));
			renderWindow.drawRectangle(winnerTextBackground);
			
			renderWindow.drawText(winnerText);
		}
		
		renderWindow.display();
	}
}

exception InvalidPlayerError(const char* const name);

CR::Player& getPlayer(const char* const playerString, CR::AIPlayer& aiPlayer, CR::HumanPlayer& humanPlayer) {
	if (strcmp(playerString, C"ai") == 0) {
		return aiPlayer;
	} else if (strcmp(playerString, C"human") == 0) {
		return humanPlayer;
	} else {
		throw InvalidPlayerError(playerString);
	}
}

// Entry point.
int main(int argc, char ** argv) {
	const char * const usage = C"chainReversi [human|ai] [human|ai] (e.g. chainReversi human ai)";
	
	if (argc != 3) {
		printf(C"Incorrect number of arguments! You need to give 2 arguments:\n");
		printf(C"    %s\n", usage);
		return 1;
	}
	
	try {
		auto renderWindow = sf::RenderWindow(sf::VideoMode(800u, 800u, 32u), C"Chain Reversi");
		renderWindow.setFramerateLimit(25);
		
		const auto view = sf::View::FromRect(sf::FloatRect(sf::Vector2f(0.0f, 0.0f), sf::Vector2f(800.0f, 800.0f)));
		renderWindow.setView(view);
		
		auto humanPlayer = CR::HumanPlayer(renderWindow);
		auto aiPlayer = CR::AIPlayer(renderWindow);
		
		final auto& player0 = getPlayer(argv[1u], aiPlayer, humanPlayer);
		final auto& player1 = getPlayer(argv[2u], aiPlayer, humanPlayer);
		
		playGame(renderWindow, player0, player1);
	} catch (InvalidPlayerError error) {
		printf(C"ERROR: Invalid player name '%s'.\n", error.name);
		return 1;
	}
	
	return 0;
}

